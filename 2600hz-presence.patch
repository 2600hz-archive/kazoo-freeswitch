From 34d41b6844f85aae1bcf6e4b8a779b7aa229acea Mon Sep 17 00:00:00 2001
From: karl anderson <karl@2600hz.com>
Date: Fri, 31 May 2013 18:19:38 -0700
Subject: [PATCH] re-commit mangle of sofia_presence, apparently we are not
 done with this approach yet...

---
 src/mod/endpoints/mod_sofia/sofia_presence.c | 236 ++++++++++++++-------------
 1 file changed, 122 insertions(+), 114 deletions(-)

diff --git a/src/mod/endpoints/mod_sofia/sofia_presence.c b/src/mod/endpoints/mod_sofia/sofia_presence.c
index 0abe14e..297fd8c 100644
--- a/src/mod/endpoints/mod_sofia/sofia_presence.c
+++ b/src/mod/endpoints/mod_sofia/sofia_presence.c
@@ -1681,6 +1681,7 @@ static int sofia_presence_sub_reg_callback(void *pArg, int argc, char **argv, ch
 	sofia_profile_t *profile = (sofia_profile_t *) pArg;
 	char *user = argv[3];
 	char *host = argv[2];
+	char *sub_to_user = argv[3];
 	switch_event_t *event;
 	char *event_name = argv[5];
 	char *expires = argv[10];
@@ -1690,9 +1691,10 @@ static int sofia_presence_sub_reg_callback(void *pArg, int argc, char **argv, ch
 	if (!strcasecmp(event_name, "message-summary")) {
 
 		if (switch_event_create(&event, SWITCH_EVENT_MESSAGE_QUERY) == SWITCH_STATUS_SUCCESS) {
-			switch_event_add_header(event, SWITCH_STACK_BOTTOM, "Message-Account", "sip:%s@%s", user, host);
+			switch_event_add_header(event, SWITCH_STACK_BOTTOM, "Message-Account", "sip:%s@%s", sub_to_user, host);
 			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "VM-Sofia-Profile", profile->name);
 			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "VM-sub-call-id", argv[7]);
+		    switch_event_add_header(event, SWITCH_STACK_BOTTOM, "VM-User", "%s@%s", user, host);
 
 			if (mod_sofia_globals.debug_presence > 0) {
 				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Create MESSAGE QUERY EVENT...\n");
@@ -1887,7 +1889,7 @@ static int sofia_dialog_probe_callback(void *pArg, int argc, char **argv, char *
 {
 	struct rfc4235_helper *h = (struct rfc4235_helper *) pArg;
 
-	char *proto = argv[0];
+	//	char *proto = argv[0];
 	char *user = argv[1];
 	char *host = argv[2];
 	char *uuid = argv[3];
@@ -1895,30 +1897,30 @@ static int sofia_dialog_probe_callback(void *pArg, int argc, char **argv, char *
 	char *state = argv[5];
 	char *direction = argv[6];
 	char *to_user = argv[7];
-	char *to_host = argv[8];
+	//	char *to_host = argv[8];
 	char *from_user = argv[9];
 	//    char *from_host = argv[10];
-	char *contact = switch_str_nil(argv[11]);
+	//	char *contact = switch_str_nil(argv[11]);
 	char *contact_user = switch_str_nil(argv[12]);
-	char *contact_host = switch_str_nil(argv[13]);
+	//	char *contact_host = switch_str_nil(argv[13]);
 	char *to_tag = switch_str_nil(argv[14]);
 	char *from_tag = switch_str_nil(argv[15]);
-	char *orig_proto = switch_str_nil(argv[16]);
+	//	char *orig_proto = switch_str_nil(argv[16]);
 
-	const char *event_status = "";
+	//	const char *event_status = "";
 	char *data = NULL, *tmp;
 	char key[256] = "";
-	char *local_user;
-	char *local_host;
-	char *remote_user;
-	char *remote_host;
-	char *remote_uri;
-	char *local_user_param = "";
-	char remote_display_buf[512];
+	//char *local_user;
+	//	char *local_host;
+	//	char *remote_user;
+	//	char *remote_host;
+	//	char *remote_uri;
+	//	char *local_user_param = "";
+	//	char remote_display_buf[512];
 	char *buf_to_free = NULL;
-	int bInternal = 0;
+	//	int bInternal = 0;
 	int i;
-	int skip_proto = 0;
+	//	int skip_proto = 0;
 
 	if (mod_sofia_globals.debug_presence > 1) {
 		for (i = 0; i < argc; i++) {
@@ -1938,7 +1940,7 @@ static int sofia_dialog_probe_callback(void *pArg, int argc, char **argv, char *
 		// because it is not going through the B2BUA
 		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "sofia_dialog_probe_callback: endpt is internal\n");
 		direction = !strcasecmp(direction, "outbound") ? "inbound" : "outbound";
-		bInternal = 1;
+		//		bInternal = 1;
 	}
 
 	if (!strcasecmp(direction, "outbound")) {
@@ -1948,83 +1950,83 @@ static int sofia_dialog_probe_callback(void *pArg, int argc, char **argv, char *
 		direction = "initiator";
 	}
 
-	if (!zstr(orig_proto) && !strcmp(orig_proto, SOFIA_CHAT_PROTO)) {
-		skip_proto = 1;
-	}
-
-	local_host = to_host;
-	if (proto && !strcasecmp(proto, "queue")) {
-		local_user = to_user;
-		local_user_param = switch_mprintf(";proto=%s", proto);
-		event_status = "hold";
-		if (skip_proto) {
-			buf_to_free = switch_mprintf("sip:%s", to_user);
-		} else {
-			buf_to_free = switch_mprintf("sip:queue+%s", to_user);
-		}
-		remote_uri = buf_to_free;
-		strcpy(remote_display_buf, "queue");
-		remote_user = to_user;
-		remote_host = local_host;
-	}
-	else if (proto && !strcasecmp(proto, "park")) {
-		local_user = to_user;
-		local_user_param = switch_mprintf(";proto=%s", proto);
-		event_status = "hold";
-		if (skip_proto) {
-			buf_to_free = switch_mprintf("sip:%s", to_user);
-		} else {
-			buf_to_free = switch_mprintf("sip:park+%s", to_user);
-		}
-		remote_uri = buf_to_free;
-		strcpy(remote_display_buf, "park");
-		remote_user = to_user;
-		remote_host = local_host;
-	}
-	else if (proto && !strcasecmp(proto, "pickup")) {
-		local_user = to_user;
-		local_user_param = switch_mprintf(";proto=%s", proto);
-		event_status = "hold";
-		if (skip_proto) {
-			buf_to_free = switch_mprintf("sip:%s", to_user);
-		} else {
-			buf_to_free = switch_mprintf("sip:pickup+%s", to_user);
-		}
-		remote_uri = buf_to_free;
-		strcpy(remote_display_buf, "pickup");
-		remote_user = to_user;
-		remote_host = local_host;
-	}
-	else if (proto && !strcasecmp(proto, "conf")) {
-		local_user = to_user;
-		local_user_param = switch_mprintf(";proto=%s", proto);
-		if (skip_proto) { 
-			buf_to_free = switch_mprintf("sip:%s@%s", to_user, host);
-		} else {
-			buf_to_free = switch_mprintf("sip:conf+%s@%s", to_user, host);
-		}
-		remote_uri = buf_to_free;
-		strcpy(remote_display_buf, "conference");
-		remote_user = to_user;
-		remote_host = local_host;
-	}
-	else if (bInternal) {
-		local_user = to_user;
-		get_display_name_from_contact(contact, remote_display_buf);
-		buf_to_free = sofia_glue_strip_uri(contact);
-		remote_uri = buf_to_free;
-		remote_user = contact_user;
-		remote_host = contact_host;
-	} else {
-		local_user = from_user;
-		buf_to_free = switch_mprintf("**%s@%s", from_user, local_host);
-		remote_uri = buf_to_free;
-		strcpy(remote_display_buf, to_user);
-		remote_user = to_user;
-		remote_host = local_host;
-	}
-
-	switch_snprintf(key, sizeof(key), "%s%s", user, host);
+	/* if (!zstr(orig_proto) && !strcmp(orig_proto, SOFIA_CHAT_PROTO)) { */
+	/* 	skip_proto = 1; */
+	/* } */
+
+	/* local_host = to_host;  */
+	/* if (proto && !strcasecmp(proto, "queue")) { */
+	/* 	local_user = to_user; */
+	/* 	local_user_param = switch_mprintf(";proto=%s", proto); */
+	/* 	event_status = "hold"; */
+	/* 	if (skip_proto) { */
+	/* 		buf_to_free = switch_mprintf("sip:%s", to_user); */
+	/* 	} else { */
+	/* 		buf_to_free = switch_mprintf("sip:queue+%s", to_user); */
+	/* 	} */
+	/* 	remote_uri = buf_to_free; */
+	/* 	strcpy(remote_display_buf, "queue"); */
+	/* 	remote_user = to_user; */
+	/* 	remote_host = local_host; */
+	/* } */
+	/* else if (proto && !strcasecmp(proto, "park")) { */
+	/* 	local_user = to_user; */
+	/* 	local_user_param = switch_mprintf(";proto=%s", proto); */
+	/* 	event_status = "hold"; */
+	/* 	if (skip_proto) { */
+	/* 		buf_to_free = switch_mprintf("sip:%s", to_user); */
+	/* 	} else { */
+	/* 		buf_to_free = switch_mprintf("sip:park+%s", to_user); */
+	/* 	} */
+	/* 	remote_uri = buf_to_free; */
+	/* 	strcpy(remote_display_buf, "park"); */
+	/* 	remote_user = to_user; */
+	/* 	remote_host = local_host; */
+	/* } */
+	/* else if (proto && !strcasecmp(proto, "pickup")) { */
+	/* 	local_user = to_user; */
+	/* 	local_user_param = switch_mprintf(";proto=%s", proto); */
+	/* 	event_status = "hold"; */
+	/* 	if (skip_proto) { */
+	/* 		buf_to_free = switch_mprintf("sip:%s", to_user); */
+	/* 	} else { */
+	/* 		buf_to_free = switch_mprintf("sip:pickup+%s", to_user); */
+	/* 	} */
+	/* 	remote_uri = buf_to_free; */
+	/* 	strcpy(remote_display_buf, "pickup"); */
+	/* 	remote_user = to_user; */
+	/* 	remote_host = local_host; */
+	/* } */
+	/* else if (proto && !strcasecmp(proto, "conf")) { */
+	/* 	local_user = to_user; */
+	/* 	local_user_param = switch_mprintf(";proto=%s", proto); */
+	/* 	if (skip_proto) {  */
+	/* 		buf_to_free = switch_mprintf("sip:%s@%s", to_user, host); */
+	/* 	} else { */
+	/* 		buf_to_free = switch_mprintf("sip:conf+%s@%s", to_user, host); */
+	/* 	} */
+	/* 	remote_uri = buf_to_free; */
+	/* 	strcpy(remote_display_buf, "conference"); */
+	/* 	remote_user = to_user; */
+	/* 	remote_host = local_host; */
+	/* } */
+	/* else if (bInternal) { */
+	/* 	local_user = to_user; */
+	/* 	get_display_name_from_contact(contact, remote_display_buf); */
+	/* 	buf_to_free = sofia_glue_strip_uri(contact); */
+	/* 	remote_uri = buf_to_free; */
+	/* 	remote_user = contact_user; */
+	/* 	remote_host = contact_host; */
+	/* } else { */
+	/* 	local_user = from_user; */
+	/* 	buf_to_free = switch_mprintf("**%s@%s", from_user, local_host); */
+	/* 	remote_uri = buf_to_free; */
+	/* 	strcpy(remote_display_buf, to_user); */
+	/* 	remote_user = to_user; */
+	/* 	remote_host = local_host; */
+	/* } */
+
+ 	switch_snprintf(key, sizeof(key), "%s%s", user, host);
 	data = switch_core_hash_find(h->hash, key);
 	if (!data) {
 		data = "";
@@ -2032,25 +2034,25 @@ static int sofia_dialog_probe_callback(void *pArg, int argc, char **argv, char *
 	tmp = switch_core_sprintf(h->pool, "%s"
 							  "<dialog id=\"%s\" call-id=\"%s\" local-tag=\"%s\" remote-tag=\"%s\" direction=\"%s\">\n"
 							  " <state>%s</state>\n"
-							  " <local>\n"
-							  "  <identity display=\"%s\">sip:%s@%s%s</identity>\n"
-							  "  <target uri=\"sip:%s@%s\">\n"
-							  "   <param pname=\"+sip.rendering\" pvalue=\"%s\"/>\n"
-							  "  </target>\n"
-							  " </local>\n"
-							  " <remote>\n"
-							  "  <identity display=\"%s\">sip:%s@%s</identity>\n"
-							  "  <target uri=\"%s\"/>\n"
-							  " </remote>\n"
+							  //" <local>\n"
+							  //"  <identity display=\"%s\">sip:%s@%s%s</identity>\n"
+							  //"  <target uri=\"sip:%s@%s\">\n"
+							  //"   <param pname=\"+sip.rendering\" pvalue=\"%s\"/>\n"
+							  //"  </target>\n"
+							  //" </local>\n"
+							  //" <remote>\n"
+							  //"  <identity display=\"%s\">sip:%s@%s</identity>\n"
+							  //"  <target uri=\"%s\"/>\n"
+							  //" </remote>\n"
 							  "</dialog>\n",
 							  data,
 							  uuid, call_id, to_tag, from_tag, direction,
-							  state,
-							  local_user, local_user, local_host, local_user_param,
-							  local_user, local_host,
-							  !strcasecmp(event_status, "hold") ? "no" : "yes",
-							  remote_display_buf, remote_user, remote_host,
-							  remote_uri
+							  state
+							  //local_user, local_user, local_host, local_user_param,
+							  //local_user, local_host,
+							  //!strcasecmp(event_status, "hold") ? "no" : "yes",
+							  //remote_display_buf, remote_user, remote_host,
+							  //remote_uri
 							  );
 	switch_core_hash_insert(h->hash, key, tmp);
 	switch_safe_free(buf_to_free);
@@ -2696,6 +2698,7 @@ static int sofia_presence_sub_callback(void *pArg, int argc, char **argv, char *
 		const char *uuid = switch_str_nil(switch_event_get_header(helper->event, "unique-id"));
 		const char *resub = switch_str_nil(switch_event_get_header(helper->event, "resub"));
 		const char *answer_state = switch_str_nil(switch_event_get_header(helper->event, "answer-state"));
+		const char *force_full = switch_str_nil(switch_event_get_header(helper->event, "force-full-dialog"));
 		const char *dft_state;
 		const char *from_id = NULL, *from_name = NULL;
 		const char *to_user = switch_str_nil(switch_event_get_header(helper->event, "variable_sip_to_user"));
@@ -2713,7 +2716,7 @@ static int sofia_presence_sub_callback(void *pArg, int argc, char **argv, char *
 		}
 
 
-		if (user_agent && switch_stristr("snom", user_agent) && uuid) {
+		if ((user_agent && switch_stristr("snom", user_agent) && uuid) || !strcasecmp(force_full, "true")) {
 			default_dialog = "full" ;
 		}
 		
@@ -2858,8 +2861,8 @@ static int sofia_presence_sub_callback(void *pArg, int argc, char **argv, char *
 			
 			if (!strcasecmp(astate, "early") || !strcasecmp(astate, "confirmed")) {
 
-				clean_to_user = switch_mprintf("%s", sub_to_user ? sub_to_user : to_user);
-				clean_from_user = switch_mprintf("%s", from_id ? from_id : from_user);
+				clean_to_user = switch_mprintf("%s", to_user);
+				clean_from_user = switch_mprintf("%s", from_user);
 
 				if (is_dialog) {
 					if (!zstr(clean_to_user) && !zstr(clean_from_user)) {
@@ -2875,7 +2878,7 @@ static int sofia_presence_sub_callback(void *pArg, int argc, char **argv, char *
 												  from_name ? from_name : clean_from_user, clean_from_user,
 												  host);
 						}
-						stream.write_function(&stream, "<target uri=\"sip:**%s@%s\"/>\n", clean_to_user, host);
+						stream.write_function(&stream, "<target uri=\"sip:%s@%s\"/>\n", clean_to_user, host);
 						stream.write_function(&stream, "</remote>\n");
 
 					} else if (!strcasecmp(proto, "queue")) {
@@ -3533,6 +3536,7 @@ void sofia_presence_handle_sip_i_subscribe(int status,
 	char *full_via = NULL;
 	char *full_agent = NULL;
 	char *sstr;
+	char *dialog_state = "new";
 	switch_event_t *sevent;
 	int sub_state = nua_substate_pending;
 	int sent_reply = 0;
@@ -3680,6 +3684,7 @@ void sofia_presence_handle_sip_i_subscribe(int status,
 	}
 
 	if (sub_state == nua_substate_active) {
+		dialog_state="active";
 		
 		sstr = switch_mprintf("active;expires=%ld", exp_delta);
 		
@@ -3698,6 +3703,7 @@ void sofia_presence_handle_sip_i_subscribe(int status,
 	} else {
 
 		if (sub_state == nua_substate_terminated) {
+			dialog_state="terminated";
 			sql = switch_mprintf("delete from sip_subscriptions where call_id='%q' and profile_name='%q' and hostname='%q'", 
 								 call_id, profile->name, mod_sofia_globals.hostname);
 		
@@ -4046,6 +4052,7 @@ void sofia_presence_handle_sip_i_subscribe(int status,
 					switch_event_add_header_string(sevent, SWITCH_STACK_BOTTOM, "alt_event_type", "dialog");
 					switch_event_add_header_string(sevent, SWITCH_STACK_BOTTOM, "expires", exp_delta_str);
 					switch_event_add_header_string(sevent, SWITCH_STACK_BOTTOM, "sub-call-id", call_id);
+		   			switch_event_add_header_string(sevent, SWITCH_STACK_BOTTOM, "dialog_state", dialog_state);
 					switch_event_fire(&sevent);
 				}
 			} else if (!strcasecmp(event, "presence")) {
@@ -4060,6 +4067,7 @@ void sofia_presence_handle_sip_i_subscribe(int status,
 					switch_event_add_header_string(sevent, SWITCH_STACK_BOTTOM, "rpid", "unknown");
 					switch_event_add_header_string(sevent, SWITCH_STACK_BOTTOM, "status", "Registered");
 					switch_event_add_header_string(sevent, SWITCH_STACK_BOTTOM, "sub-call-id", call_id);
+		   			switch_event_add_header_string(sevent, SWITCH_STACK_BOTTOM, "dialog_state", dialog_state);
 					switch_event_fire(&sevent);
 				}					
 			}
-- 
1.8.3

